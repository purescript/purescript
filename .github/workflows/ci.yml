name: "CI"

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  release:
    types: [ "published" ]

defaults:
  run:
    shell: "bash"

env:
  CI_RELEASE: "${{ github.event_name == 'release' }}"

jobs:
  build:
    strategy:
      fail-fast: false # do not cancel builds for other OSes if one fails
      matrix:
        # If upgrading Ubuntu, also upgrade it in the lint job below
        # and the package-set job below
        os: [ "ubuntu-18.04", "macOS-10.15", "windows-2016" ]

    runs-on: "${{ matrix.os }}"

    steps:
      - uses: "actions/checkout@v2"

      - uses: "actions/setup-node@v1"
        with:
          node-version: "10"

      - id: "haskell"
        uses: "haskell/actions/setup@v1"
        with:
          enable-stack: true
          # If upgrading Stack, also upgrade it in the lint job below
          # and the package-set job below
          stack-version: "2.7.1"
          stack-no-global: true

      - uses: "actions/cache@v2"
        with:
          path: |
            ${{ steps.haskell.outputs.stack-root }}
          key: "${{ runner.os }}-${{ hashFiles('stack.yaml') }}"

      - name: "(Windows only) Configure Stack to store its programs in STACK_ROOT"
        # This ensures that the local GHC and MSYS binaries that Stack installs
        # are included in the cache. (This behavior is the default on
        # non-Windows OSes.)
        if: "${{ runner.os == 'Windows' }}"
        run: |
          mkdir -p "$STACK_ROOT"
          echo "local-programs-path: $STACK_ROOT/programs" > $STACK_ROOT/config.yaml

      - run: "ci/build.sh"

      - name: "(Ubuntu only) Copy `purs` binary to static easily-referrable location"
        if: "${{ runner.os == 'Linux' }}"
        run: |
          pushd ~/
          mkdir -p bin
          popd

          pushd sdist-test
          cp $(stack path --local-doc-root)/../bin/purs ~/bin/purs
          pushd ~
          chmod +x bin/purs
          ./bin/purs --version
          popd
          popd

      - name: "(Ubuntu only) Make `purs` binary available for package-set job"
        if: "${{ runner.os == 'Linux' }}"
        uses: actions/upload-artifact@v2
        with:
          name: purs-binary
          path: ~/bin/purs
          retention-days: 1

      - name: "(Release only) Create bundle"
        if: "${{ env.CI_RELEASE == 'true' }}"
        run: |
          os_name="${{ runner.os }}"
          case "$os_name" in
            Linux)
              bundle_os=linux64;;
            macOS)
              bundle_os=macos;;
            Windows)
              bundle_os=win64;;
            *)
              echo "Unknown OS name: $os_name"
              exit 1;;
          esac
          cd sdist-test
          bundle/build.sh "$bundle_os"

      - name: "(Release only) Publish bundle"
        if: "${{ env.CI_RELEASE == 'true' }}"
        # Astonishingly, GitHub doesn't currently maintain a first-party action
        # for uploading assets to GitHub releases! This is the best third-party
        # one I could find, but as this step handles a token, it seems
        # particularly important that we lock it down to a specific audited
        # version, instead of a tag like the other steps.
        uses: "AButler/upload-release-assets@ec6d3263266dc57eb6645b5f75e827987f7c217d"
        with:
          repo-token: "${{ secrets.GITHUB_TOKEN }}"
          files: "sdist-test/bundle/*.{tar.gz,sha}"

  lint:
    runs-on: "ubuntu-18.04"

    steps:
      - uses: "actions/checkout@v2"

      - id: "haskell"
        uses: "haskell/actions/setup@v1"
        with:
          enable-stack: true
          stack-version: "2.7.1"
          stack-no-global: true

      - uses: "actions/cache@v2"
        with:
          path: |
            ${{ steps.haskell.outputs.stack-root }}
          key: "${{ runner.os }}-lint-${{ hashFiles('stack.yaml') }}"

      - run: "ci/run-hlint.sh --git"
        env:
          VERSION: "2.2.11"

      - run: "stack --no-terminal --jobs=2 build --copy-compiler-tool weeder"

      - run: "stack --no-terminal --jobs=2 build --fast --ghc-options -fwrite-ide-info"

      - run: "stack exec weeder"

      # Now do it again, with the test suite included. We don't want a
      # reference from our test suite to count in the above check; the fact
      # that a function is tested is not evidence that it's needed. But we also
      # don't want to leave weeds lying around in our test suite either.
      - run: "stack --no-terminal --jobs=2 build --fast --test --no-run-tests --ghc-options -fwrite-ide-info"

      - run: "stack exec weeder"

  package-set:
    runs-on: "ubuntu-18.04"
    needs: build

    steps:
      - uses: actions/download-artifact@v2
        with:
          name: purs-binary
          path: ~/bin

      - run: |
          # Uploading/Downloading artifact does not retain
          # file permissions
          pushd ~/bin
          chmod +x purs
          ./purs --version
          popd

          # See https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#adding-a-system-path
          echo "~/bin" >> $GITHUB_PATH

      - uses: "actions/setup-node@v1"
        with:
          node-version: "10"

      - name: Cache PureScript dependencies
        uses: actions/cache@v2
        with:
          key: ${{ runner.os }}-spago-${{ hashFiles('**/*.dhall') }}
          path: |
            .spago
            output

      - name: Cache NPM dependencies
        uses: actions/cache@v2
        env:
          cache-name: cache-node-modules
        with:
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-

      - name: Install NPM dependencies
        run: npm install -g spago

      - name: Compile and run docs on package set
        run: |
          echo $PATH
          purs --version

          (echo "::group::Init Spago project") 2>/dev/null
          spago init --no-comments
          (echo "::endgroup::"; "::group::Upgrade to latest package set") 2>/dev/null

          # Ensure we're on the latest package set
          spago upgrade-set

          (echo "::endgroup::"; "::group::Override metadata package version") 2>/dev/null

          # Override the `metadata` package's version to match `purs` version
          # so that `spago build` actually works
          META_PACKAGE_VERSION="v$(purs --version | cut -d ' ' -f 1)"
          echo $(head --lines=-1 packages.dhall) > packages.dhall
          echo "in upstream with metadata.version = \"$META_PACKAGE_VERSION\"" >> packages.dhall

          (echo "::endgroup::"; "::group::Install package set") 2>/dev/null
          spago install $(spago ls packages | cut -d ' ' -f 1 | tr '\n' ' ')

          (echo "::endgroup::"; "::group::Compile package set") 2>/dev/null
          spago build

          (echo "::endgroup::"; "::group::Document package set") 2>/dev/null
          spago docs --no-search

          (echo "::endgroup::") 2>/dev/null
