-----------------------------------------------------------------------------
--
-- Module      :  psc-bundle
-- Copyright   :  (c) Phil Freeman 2015
-- License     :  MIT
--
-- Maintainer  :  Phil Freeman <paf31@cantab.net>
-- Stability   :  experimental
-- Portability :
--
-- | Bundles compiled PureScript modules for the browser.
--
-- This module takes as input the individual generated modules from 'Language.PureScript.Make' and
-- performs dead code elimination, filters empty modules,
-- and generates the final Javascript bundle.
-----------------------------------------------------------------------------

{-# LANGUAGE PatternGuards #-}

module Language.PureScript.BundleTypes where

import Prelude
import Language.JavaScript.Parser
import Language.JavaScript.Parser.AST

-- | Modules are either "regular modules" (i.e. those generated by psc) or foreign modules.
data ModuleType
  = Regular
  | Foreign
  deriving (Show, Read, Eq, Ord)

showModuleType :: ModuleType -> String
showModuleType Regular = "Regular"
showModuleType Foreign = "Foreign"

-- | A module is identified by its module name and its type.
data ModuleIdentifier = ModuleIdentifier String ModuleType deriving (Show, Read, Eq, Ord)

moduleName :: ModuleIdentifier -> String
moduleName (ModuleIdentifier name _) = name

-- | A piece of code is identified by its module and its name. These keys are used to label vertices
-- in the dependency graph.
type Key = (ModuleIdentifier, String)

-- | An export is either a "regular export", which exports a name from the regular module we are in,
-- or a reexport of a declaration in the corresponding foreign module.
--
-- Regular exports are labelled, since they might re-export an operator with another name.
data ExportType
  = RegularExport String
  | ForeignReexport
  deriving (Show, Eq, Ord)

-- | There are four types of module element we are interested in:
--
-- 1) Require statements
-- 2) Member declarations
-- 3) Export lists
-- 4) Everything else
--
-- Each is labelled with the original AST node which generated it, so that we can dump it back
-- into the output during codegen.
data ModuleElement
  = Require JSStatement String (Either String ModuleIdentifier)
  | Member JSStatement Bool String JSExpression [Key]
  | ExportsList [(ExportType, String, JSExpression, [Key])]
  | Other JSStatement
  deriving (Show)

-- | A module is just a list of elements of the types listed above.
data Module = Module ModuleIdentifier [ModuleElement] deriving (Show)

-- *Helpers for JSCommaList

toJSCommaList :: [a] -> JSCommaList a
toJSCommaList [] = JSLNil
toJSCommaList [a] = JSLOne a
toJSCommaList (hd:rest) = JSLCons (toJSCommaList rest) JSNoAnnot hd

fromJSCommaList :: JSCommaList a -> [a]
fromJSCommaList JSLNil = []
fromJSCommaList (JSLOne a) = [a]
fromJSCommaList  (JSLCons list _ hd) = hd : fromJSCommaList list

lengthJSCommaList :: JSCommaList a -> Int
lengthJSCommaList = length . fromJSCommaList

mapJSCommaList :: (a -> b) -> JSCommaList a -> JSCommaList b
mapJSCommaList func inp = toJSCommaList (map func (fromJSCommaList inp))

mapJSCommaTrailingList :: (a -> b) -> JSCommaTrailingList a -> JSCommaTrailingList b
mapJSCommaTrailingList func (JSCTLComma inp a) = JSCTLComma (mapJSCommaList func inp) a
mapJSCommaTrailingList func (JSCTLNone inp)    = JSCTLNone (mapJSCommaList func inp)

consJSCommaList :: a -> JSCommaList a -> JSCommaList a
consJSCommaList a li = JSLCons li JSNoAnnot a

reverseJSCommaList :: JSCommaList JSIdent -> JSCommaList JSIdent
reverseJSCommaList = toJSCommaList . reverse . fromJSCommaList
