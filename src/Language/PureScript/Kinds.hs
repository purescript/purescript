{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveTraversable #-}

module Language.PureScript.Kinds where

import Prelude.Compat

import GHC.Generics (Generic)
import Control.DeepSeq (NFData)
import Data.Function (fix)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Aeson.BetterErrors (Parse, key, asText, asIntegral, nth, fromAesonParser, toAesonParser, throwCustomError, (<|>))
import Data.Aeson ((.=))
import qualified Data.Aeson as A

import Language.PureScript.AST.SourcePos
import Language.PureScript.Names
import qualified Language.PureScript.Constants as C

-- | The data type of kinds
data Kind a
  -- | Unification variable of type Kind
  = KUnknown a Int
  -- | Kinds for labelled, unordered rows without duplicates
  | Row a (Kind a)
  -- | Function kinds
  | FunKind a (Kind a) (Kind a)
  -- | A named kind
  | NamedKind a (Qualified (ProperName 'KindName))
  deriving (Show, Eq, Ord, Generic, Functor, Foldable, Traversable)

instance NFData a => NFData (Kind a)

-- This is equivalent to the derived Aeson ToJSON instance, except that we
-- write it out manually so that we can define a parser which is
-- backwards-compatible.
instance A.ToJSON a => A.ToJSON (Kind a) where
  toJSON kind = case kind of
    KUnknown a i ->
      obj "KUnknown" a i
    Row a k ->
      obj "Row" a k
    FunKind a k1 k2 ->
      obj "FunKind" a [k1, k2]
    NamedKind a n ->
      obj "NamedKind" a n
    where
    obj :: A.ToJSON b => Text -> a -> b -> A.Value
    obj tag ann contents =
      A.object [ "tag" .= tag, "annotation" .= ann, "contents" .= contents ]

-- This is equivalent to the derived Aeson FromJSON instance, except that it
-- also handles JSON generated by compilers up to 0.10.3 and maps them to the
-- new representations (i.e. NamedKinds which are defined in the Prim module).
kindFromJSON :: a -> (Parse Text a) -> Parse Text (Kind a)
kindFromJSON defaultAnn annFromJSON = fix $ \go -> do
  t <- key "tag" asText
  let annFromJSON' = key "annotation" annFromJSON <|> pure defaultAnn
  case t of
    "KUnknown" ->
      KUnknown <$> annFromJSON' <*> key "contents" (nth 0 asIntegral)
    "Star" ->
      pure (kindType defaultAnn)
    "Row" ->
      Row <$> annFromJSON' <*> key "contents" go
    "FunKind" ->
      let
        kindAt n = key "contents" (nth n go)
      in
        FunKind <$> annFromJSON' <*> kindAt 0 <*> kindAt 1
    "Symbol" ->
      pure (kindSymbol defaultAnn)
    "NamedKind" ->
      NamedKind <$> annFromJSON' <*> key "contents" fromAesonParser
    other ->
      throwCustomError (T.append "Unrecognised tag: " other)

  where
  -- The following are copied from Environment and reimplemented to avoid
  -- circular dependencies.
  primName :: Text -> Qualified (ProperName b)
  primName = Qualified (Just $ ModuleName [ProperName C.prim]) . ProperName

  primKind = flip NamedKind . primName

  kindType = primKind C.typ
  kindSymbol = primKind C.symbol

instance A.FromJSON (Kind SourceAnn) where
  parseJSON = toAesonParser id (kindFromJSON nullSourceAnn fromAesonParser)

everywhereOnKinds :: (Kind a -> Kind a) -> Kind a -> Kind a
everywhereOnKinds f = go
  where
  go (Row ann k1) = f (Row ann (go k1))
  go (FunKind ann k1 k2) = f (FunKind ann (go k1) (go k2))
  go other = f other

everywhereOnKindsM :: Monad m => (Kind a -> m (Kind a)) -> Kind a -> m (Kind a)
everywhereOnKindsM f = go
  where
  go (Row ann k1) = (Row ann <$> go k1) >>= f
  go (FunKind ann k1 k2) = (FunKind ann <$> go k1 <*> go k2) >>= f
  go other = f other

everythingOnKinds :: (r -> r -> r) -> (Kind a -> r) -> Kind a -> r
everythingOnKinds (<>.) f = go
  where
  go k@(Row _ k1) = f k <>. go k1
  go k@(FunKind _ k1 k2) = f k <>. go k1 <>. go k2
  go other = f other

annotationForKind :: Kind a -> a
annotationForKind (KUnknown a _) = a
annotationForKind (Row a _) = a
annotationForKind (FunKind a _ _) = a
annotationForKind (NamedKind a _) = a
