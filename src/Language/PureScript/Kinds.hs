{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveTraversable #-}

module Language.PureScript.Kinds where

import Prelude.Compat

import GHC.Generics (Generic)
import Control.DeepSeq (NFData)
import Data.Function (fix)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Aeson.BetterErrors (Parse, key, asText, asIntegral, nth, fromAesonParser, toAesonParser, throwCustomError, (<|>))
import Data.Aeson ((.=))
import qualified Data.Aeson as A

import Language.PureScript.AST.SourcePos
import Language.PureScript.Names
import qualified Language.PureScript.Constants as C

type SourceKind = Kind SourceAnn

-- | The data type of kinds
data Kind a
  -- | Unification variable of type Kind
  = KUnknown a Int
  -- | Kinds for labelled, unordered rows without duplicates
  | Row a (Kind a)
  -- | Function kinds
  | FunKind a (Kind a) (Kind a)
  -- | A named kind
  | NamedKind a (Qualified (ProperName 'KindName))
  deriving (Show, Generic, Functor, Foldable, Traversable)

instance NFData a => NFData (Kind a)

srcKUnknown :: Int -> SourceKind
srcKUnknown = KUnknown NullSourceAnn

srcRow :: SourceKind -> SourceKind
srcRow = Row NullSourceAnn

srcFunKind :: SourceKind -> SourceKind -> SourceKind
srcFunKind = FunKind NullSourceAnn

srcNamedKind :: Qualified (ProperName 'KindName) -> SourceKind
srcNamedKind = NamedKind NullSourceAnn

instance A.ToJSON a => A.ToJSON (Kind a) where
  toJSON kind = case kind of
    KUnknown a i ->
      obj "KUnknown" a i
    Row a k ->
      obj "Row" a k
    FunKind a k1 k2 ->
      obj "FunKind" a [k1, k2]
    NamedKind a n ->
      obj "NamedKind" a n
    where
    obj :: A.ToJSON b => Text -> a -> b -> A.Value
    obj tag ann contents =
      A.object [ "tag" .= tag, "annotation" .= ann, "contents" .= contents ]

-- This handles JSON generated by compilers up to 0.10.3 and maps them to the
-- new representations (i.e. NamedKinds which are defined in the Prim module).
kindFromJSON :: Parse Text a -> Parse Text a -> Parse Text (Kind a)
kindFromJSON defaultAnn annFromJSON = fix $ \go -> do
  t <- key "tag" asText
  let annFromJSON' = key "annotation" annFromJSON <|> defaultAnn
  case t of
    "KUnknown" ->
      KUnknown <$> annFromJSON' <*> key "contents" (nth 0 asIntegral)
    "Star" ->
      kindType <$> defaultAnn
    "Row" ->
      Row <$> annFromJSON' <*> key "contents" go
    "FunKind" ->
      let
        kindAt n = key "contents" (nth n go)
      in
        FunKind <$> annFromJSON' <*> kindAt 0 <*> kindAt 1
    "Symbol" ->
      kindSymbol <$> defaultAnn
    "NamedKind" ->
      NamedKind <$> annFromJSON' <*> key "contents" fromAesonParser
    other ->
      throwCustomError (T.append "Unrecognised tag: " other)

  where
  -- The following are copied from Environment and reimplemented to avoid
  -- circular dependencies.
  primName :: Text -> Qualified (ProperName b)
  primName = Qualified (Just $ ModuleName [ProperName C.prim]) . ProperName

  primKind = flip NamedKind . primName

  kindType = primKind C.typ
  kindSymbol = primKind C.symbol

-- These overlapping instances exist to preserve compatability for common
-- instances which have a sensible default for missing annotations.
instance {-# OVERLAPPING #-} A.FromJSON (Kind SourceAnn) where
  parseJSON = toAesonParser id (kindFromJSON (pure NullSourceAnn) fromAesonParser)

instance {-# OVERLAPPING #-} A.FromJSON (Kind ()) where
  parseJSON = toAesonParser id (kindFromJSON (pure ()) fromAesonParser)

instance {-# OVERLAPPING #-} A.FromJSON a => A.FromJSON (Kind a) where
  parseJSON = toAesonParser id (kindFromJSON (fail "Invalid annotation") fromAesonParser)

everywhereOnKinds :: (Kind a -> Kind a) -> Kind a -> Kind a
everywhereOnKinds f = go
  where
  go (Row ann k1) = f (Row ann (go k1))
  go (FunKind ann k1 k2) = f (FunKind ann (go k1) (go k2))
  go other = f other

everywhereOnKindsM :: Monad m => (Kind a -> m (Kind a)) -> Kind a -> m (Kind a)
everywhereOnKindsM f = go
  where
  go (Row ann k1) = (Row ann <$> go k1) >>= f
  go (FunKind ann k1 k2) = (FunKind ann <$> go k1 <*> go k2) >>= f
  go other = f other

everythingOnKinds :: (r -> r -> r) -> (Kind a -> r) -> Kind a -> r
everythingOnKinds (<>.) f = go
  where
  go k@(Row _ k1) = f k <>. go k1
  go k@(FunKind _ k1 k2) = f k <>. go k1 <>. go k2
  go other = f other

annotationForKind :: Kind a -> a
annotationForKind (KUnknown a _) = a
annotationForKind (Row a _) = a
annotationForKind (FunKind a _ _) = a
annotationForKind (NamedKind a _) = a

instance Eq (Kind a) where
  (==) = eqKind

instance Ord (Kind a) where
  compare = compareKind

eqKind :: Kind a -> Kind b -> Bool
eqKind (KUnknown _ a) (KUnknown _ a') = a == a'
eqKind (Row _ a) (Row _ a') = eqKind a a'
eqKind (FunKind _ a b) (FunKind _ a' b') = eqKind a a' && eqKind b b'
eqKind (NamedKind _ a) (NamedKind _ a') = a == a'
eqKind _ _ = False

compareKind :: Kind a -> Kind b -> Ordering
compareKind (KUnknown _ a) (KUnknown _ a') = compare a a'
compareKind (KUnknown {}) _ = LT

compareKind (Row _ a) (Row _ a') = compareKind a a'
compareKind (Row {}) _ = LT
compareKind _ (Row {}) = GT

compareKind (FunKind _ a b) (FunKind _ a' b') = compareKind a b <> compareKind a' b'
compareKind (FunKind {}) _ = LT
compareKind _ (FunKind {}) = GT

compareKind (NamedKind _ a) (NamedKind _ a') = compare a a'
compareKind (NamedKind {}) _ = GT
